<!-- AI Assistant Bottom Bar -->
<div x-data="aiAssistant()"
     :style="`right:0;left: ${$store.sidebar.expanded ? '18rem' : '5rem'}`"
     class="fixed bottom-0 z-50 transition-all duration-300">

    <!-- Toggle Button (when closed) -->
    <button x-show="!open"
      @click="openAssistant()"
      class="absolute right-4 bottom-4 dark:bg-slate-800 bg-slate-200 text-slate-800 dark:text-white px-4 py-2
      rounded-full shadow-lg flex items-center gap-2 hover:bg-slate-300 dark:hover:bg-slate-700 transition">
        <i data-lucide="bot" class="w-4 h-4"></i>AI Assistant
    </button>

    <!-- Sliding Panel -->
    <div x-show="open"
        x-transition:enter="transform transition ease-out duration-300"
        x-transition:enter-start="translate-y-full"
        x-transition:enter-end="translate-y-0"
        x-transition:leave="transform transition ease-in duration-200"
        x-transition:leave-start="translate-y-0"
        x-transition:leave-end="translate-y-full"
        class="dark:bg-slate-900 bg-slate-100 text-slate-900 dark:text-white h-96 w-full shadow-2xl rounded-t-xl p-4 flex flex-col">
        <!-- Header -->
        <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-2">
                <i data-lucide="bot" class="w-5 h-5"></i>
                <span class="font-semibold">AI Copilot Assistant</span>
            </div>
            <button @click="close()" class="hover:text-slate-700 dark:hover:text-slate-300">
                <i data-lucide="chevron-down" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- Conversation Display -->
        <div id="aiConversation" class="flex-1 overflow-y-auto dark:bg-slate-800 bg-slate-200 p-3 rounded-lg text-sm space-y-2">
        </div>

        <!-- Input -->
        <div class="mt-3 flex gap-2">
            <input x-ref="aiInput"
                @keydown.enter="sendUserMessage()"
                type="text"
                placeholder="Write your question..."
                class="flex-1 rounded-md p-2 text-white dark:text-slate-800">
            <button @click="sendUserMessage()"
                    class="bg-blue-600 hover:bg-blue-500 text-white px-4 rounded-md">
                Send
            </button>
        </div>
    </div>
</div>
<script>
    /** Utilities **/
    function escapeHtmlForPreview(str) {
        if (!str) return "";
        return str
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
    }

    /** aiAssistant avec streaming Markdown + final sanitize **/
    function aiAssistant(options = {}) {

        return {
            open: false,
            ws: null,
            connected: false,
            sessionID: null,
            aiBuffer: "",
            aiCurrentBubble: null,
            isCurrentFinalized: false,

            init() {
                this.connectWebSocket();

                document.addEventListener('open-debug-assistant', (e) => {
                    const { subject, content } = e.detail;
                    this.openWithSubject(subject, content);
                });
            },

            connectWebSocket() {

                const protocol = window.location.protocol === "https:" ? "wss://" : "ws://";
                const host = window.location.host;
                const pageName = document.querySelector('meta[name="active-submenu"]')?.content;
                const fullPath = window.location.pathname;
                const context = pageName ? fullPath.replace("/" + pageName, "") : "";

                // Build WebSocket URL
                const wsUrl = `${protocol}${host}${context}/api/ws/AIWebSocket`;
                console.info("WebSocket URL:", wsUrl);

                // Connect to WebSocket endpoint
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    this.connected = true;
                };

                this.ws.onclose = () => {
                    this.connected = false;
                    setTimeout(() => this.connectWebSocket(), 2000);
                };

                this.ws.onerror = (err) => {
                    console.error("WebSocket error:", err);
                };

                this.ws.onmessage = (event) => {
                    // parse JSON if possible
                    let parsed = null;
                    try {
                        parsed = JSON.parse(event.data);
                    } catch (e) {
                        // if not JSON, stream text
                        this.appendAI(String(event.data), false, false);
                        return;
                    }

                    // Supporte plusieurs formats de serveurs : json.data, json.delta, json.chunk, json.text
                    const chunk = (parsed.data ?? parsed.delta ?? parsed.chunk ?? parsed.text ?? "");
                    const type = parsed.type ?? null;
                    const doneFlag = parsed.done === true || parsed.type === 'end' || chunk === "";

                    // If title, handle differently
                    if (type === 'title') {
                        //TODO
                        return;
                    }

                    // Append the chunk to the current AI bubble (stream)
                    this.appendAI(chunk, false, doneFlag);
                };
            },

            openAssistant() {
                this.open = true;
                const input = this.$refs.aiInput;

                if (!this.sessionID) {
                    this.sessionID = crypto.randomUUID();

                    var username = getUser().name;
                    const language = getUser().language === "en" ? "English" : "French";
                    const pageMeta = document.querySelector('meta[name="page"]');
                    const pageName = pageMeta ? pageMeta.content : "unknown page";

                    const payload = {
                        subject: "chat_with_ai",
                        sender: getUser().login,
                        sessionID: this.sessionID,
                        content:
                            "Hello, I'm " + username + ". I'm working in a software development context, in a job related to Quality Assurance (automation, tester)." +
                            "The context of the question is related to Cerberus-Testing, a low-code testing framework. " +
                            "Could you give me 2 or 3 examples of things that I can ask you related to the page " + pageName + " in Cerberus-Testing? " +
                            "Please, answer in " + language + "language." +
                            "Be concise, and Answer in Markdown format, using **bold**, _italic_, lists, code blocks, and proper Markdown syntax."

                    };

                    if (this.connected) this.ws.send(JSON.stringify(payload));

                    //empty the input
                    input.value = "";

                    // prepare a new AI bubble for the streaming response
                    this.appendAI("", true, false);
                }

            },

            close() {
                this.open = false;
            },

            sendUserMessage() {
                this.aiBuffer = "";
                const input = this.$refs.aiInput;
                const msg = input.value.trim();
                if (!msg) return;

                this.addMessage("user", msg);

                if (!this.sessionID) this.sessionID = crypto.randomUUID();

                const payload = {
                    subject: "chat_with_ai",
                    sender: getUser().login,
                    sessionID: this.sessionID,
                    content: msg
                };

                if (this.connected) this.ws.send(JSON.stringify(payload));

                input.value = "";

                // prepare a new AI bubble for the streaming response
                this.appendAI("", true, false);
            },

            /**
             * appendAI(chunk, isNew, isFinal)
             *  - chunk : string fragment reÃ§u (possibly empty)
             *  - isNew : true -> create new bubble (start of answer)
             *  - isFinal : true -> server signals end -> sanitize + finalize bubble
             */
            appendAI(chunk, isNew = false, isFinal = false) {
                const conv = document.getElementById("aiConversation");
                if (!conv) return;

                // create new bubble if needed
                if (isNew || !this.aiCurrentBubble || this.isCurrentFinalized) {
                    const bubble = document.createElement("div");
                    bubble.className = "ai-msg dark:bg-slate-700 bg-slate-300 dark:text-white text-slate-900 p-3 rounded-lg max-w-m";
                    bubble.setAttribute('data-streaming', 'true');
                    conv.appendChild(bubble);
                    this.aiCurrentBubble = bubble;
                    this.aiBuffer = "";
                    this.isCurrentFinalized = false;
                }

                // append chunk to buffer (keep raw markdown)
                this.aiBuffer += chunk;

                // During streaming: render a safe preview
                //  - escape any raw HTML first to prevent execution during streaming
                //  - then parse markdown to HTML for visual richness
                try {
                    const previewSource = escapeHtmlForPreview(this.aiBuffer);
                    const previewHtml = marked.parse(previewSource);
                    // show preview (no DOMPurify here, because we escaped raw HTML)
                    this.aiCurrentBubble.innerHTML = previewHtml;
                } catch (e) {
                    // fallback: render as text to avoid DOM errors
                    this.aiCurrentBubble.textContent = this.aiBuffer;
                }

                conv.scrollTop = conv.scrollHeight;

                // if this chunk signals end of message -> finalize
                if (isFinal) {
                    this.finalizeCurrentAI();
                }
            },

            finalizeCurrentAI() {
                if (!this.aiCurrentBubble) return;

                // parse original buffer (allow markdown to include HTML if present),
                // then sanitize the resulting HTML with DOMPurify
                try {
                    const finalHtml = marked.parse(this.aiBuffer);
                    const clean = DOMPurify.sanitize(finalHtml, {
                        ALLOWED_TAGS: [
                            'b','i','strong','em','ul','ol','li','p','div','span',
                            'code','pre','br','hr','h1','h2','h3','h4','table','thead','tbody','tr','th','td'
                        ],
                        ALLOWED_ATTR: ['class','style']
                    });
                    this.aiCurrentBubble.innerHTML = clean;
                } catch (e) {
                    // fallback to escaped text
                    this.aiCurrentBubble.textContent = this.aiBuffer;
                }

                this.aiCurrentBubble.removeAttribute('data-streaming');
                this.isCurrentFinalized = true;
                this.aiBuffer = "";
            },

            addMessage(who, text) {
                const conv = document.getElementById("aiConversation");
                if (!conv) return;

                const bubble =
                    '<div class="' + (who === "ai" ? 'bg-slate-700 text-white' : 'bg-blue-600 text-white ml-auto') +
                    ' p-3 rounded-lg max-w-m">' + DOMPurify.sanitize(text) + '</div>';

                conv.insertAdjacentHTML("beforeend", bubble);
                conv.scrollTop = conv.scrollHeight;
            },

            /*
            Open bar with specific subject
             */
            openWithSubject(subject, content) {
                this.open = true;
                if (!this.sessionID) this.sessionID = crypto.randomUUID();

                const payload = {
                    subject: subject,
                    sender: getUser().login,
                    sessionID: this.sessionID,
                    content: content || ""
                };

                if (this.connected) this.ws.send(JSON.stringify(payload));

                // prepare bubble for streaming response
                this.appendAI("", true, false);
            }
        };
    }
</script>